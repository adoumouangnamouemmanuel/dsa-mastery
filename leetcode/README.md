# ğŸ§© LeetCode Practice (Java)

This directory contains my solutions to LeetCode problems implemented in **Java**. My focus is on utilizing the **Java Collections Framework** (ArrayList, HashMap, PriorityQueue, etc.) to build efficient, readable, and scalable solutions for my academic labs and personal practice.

## ğŸ“‚ Problem Categories

| Topic | Description | Status |
| :--- | :--- | :--- |
| ğŸŸ¢ [**Arrays & Hashing**](./arrays-hashing/) | Usage of `HashMap`, `HashSet`, and primitive arrays. | In Progress |
| ğŸŸ¡ [**Two Pointers**](./two-pointers/) | Optimal linear searching and in-place manipulation. | Planned |
| âšª [**Sliding Window**](./sliding-window/) | Tracking subsets of data within linear structures. | Planned |
| ğŸ”´ [**Stacks & Queues**](./stacks-queues/) | LIFO/FIFO logic using `Deque` and `Stack`. | Planned |
| ğŸŸ£ [**Linked Lists**](./linked-lists/) | Manual pointer/reference manipulation and traversal. | In Progress |
| ğŸ” [**Binary Search**](./binary-search/) | Efficient searching in $O(\log n)$ time. | Planned |
| ğŸŒ³ [**Trees & Graphs**](./trees-graphs/) | Hierarchical data, BFS, DFS, and recursion. | Planned |
| ğŸ” [**Heap / Priority Queue**](./heap/) | Handling min/max elements and K-way merging. | Planned |
| â±ï¸ [**Intervals**](./intervals/) | Overlapping ranges and scheduling problems. | Planned |
| ğŸ”³ [**Matrix**](./matrix/) | 2D array traversals and transformations. | Planned |
| âœï¸ [**Strings**](./string/) | Manipulation using `StringBuilder` and pattern matching. | Planned |
| âš¡ [**Dynamic Programming**](./dynamic-programming/) | Optimization via Memoization and Tabulation. | Planned |
| ğŸ“Š [**Sorting**](./sorting/) | Implementation of Merge, Quick, and Heap sort. | Planned |
| ğŸ•¸ï¸ [**Advanced Graph**](./advanced-graph/) | Dijkstra, Topological Sort, and Union-Find. | Planned |
| ğŸ—ï¸ [**Design**](./design/) | Building custom data structures and LRU caches. | Planned |

---

## ğŸ› ï¸ Java Implementation Standards
To maintain a high standard for my **2027 Master's applications**, I follow these coding principles:
* **Naming Conventions:** Class names follow `PascalCase` (e.g., `TwoSum.java`).
* **Efficiency:** Prioritizing $O(n)$ or $O(\log n)$ time complexity wherever possible.
* **Collections Framework:** Leveraging `java.util.*` effectively to reduce boilerplate.
* **Documentation:** Including Javadoc-style comments to explain the algorithmic approach.

## ğŸš€ Roadmap
- [ ] Master **Big O Analysis** for all Java Collection operations (e.g., `ArrayList.get()` vs `LinkedList.get()`).
- [ ] Solve 75 essential "Blind 75" problems in Java.
- [ ] Complete all **In-Class Lab** requirements using idiomatic Java.

---
*Last Updated: February 2026 | Location: Ghana ğŸ‡¬ğŸ‡­*